#!/usr/bin/env ruby
# Run Kitchenplan.

require "pathname"

if ENV["USER"] == "root"
  abort "Run this as a normal user, I'll sudo if I need to."
end

# Make sure only one kitchenplan process runs at a time.

myself = File.new __FILE__

unless myself.flock File::LOCK_EX | File::LOCK_NB
  abort "You're already running a kitchenpan process! Know a patience."
end

# Yeah yeah, I like to be explicit.

at_exit { myself.flock File::LOCK_UN }

# Put us where we belong, in the root dir of our kitchenplan repo.

Dir.chdir Pathname.new(__FILE__).realpath + ".."

# Flags
require 'optparse'

options = {}
OptionParser.new do |opts|
    opts.banner = "Usage: kitchenplan [options]"

    opts.on("-d", "--debug", "Show debug information") do |debug|
        options[:debug] = debug
    end

    opts.on("-g", "--update-gems", "Update the RubyGems") do |update_gems|
        options[:update_gems] = update_gems
    end

    opts.on("-c", "--update-cookbooks", "Update the Chef cookbooks") do |update_cookbooks|
        options[:update_cookbooks] = update_cookbooks
    end

    options[:soloist] = true
    opts.on("--[no-]soloist", "Run soloist (defaults to yes)") do |soloist|
        options[:soloist] = soloist
    end

    options[:update] = true
    opts.on("--[no-]update", "Run the kitchenplan update (defaults to yes)") do |update|
        options[:update] = update
    end

    opts.separator ""
    opts.separator "Common options:"

    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end

    opts.on_tail("--version", "Show version") do
        puts "1.0.1"
        exit
    end

end.parse!

# Auto-update code. This is done as early as possible so that changes
# to kitchenplan support code or dependencies can be grabbed.

unless options[:update]
    if system("which git > /dev/null") && File.directory?(".git")
        clean  = `git status --porcelain`.empty?
        current_branch = `git symbolic-ref HEAD`.chomp
        master = current_branch == "refs/heads/master"
        no_new_commits = system('git diff --exit-code --quiet origin/master master')
        short_branch = current_branch.split('/').last
        if !master
            warn "Kitchenplan on a non-master branch '#{short_branch}', won't auto-update!"
        elsif !no_new_commits
            warn "Kitchenplan has unpushed commits on master, won't auto-update!"
        elsif !clean
            warn "Kitchenplan has a dirty tree, won't auto-update!"
        end
        if clean && master && no_new_commits
            quietly = "> /dev/null 2>&1"
            fetch   = "(git fetch origin #{quietly})"
            reset   = "(git reset --hard origin/master #{quietly})"
            reclean = "(git clean -df #{quietly})"
            unless system "#{fetch} && #{reset} && #{reclean}"
                warn "Auto-update of Kitchenplan FAILED, continuing."
            end
        end
    end
end

# Bootstrapping dependencies

unless system("(gem spec bundler -v '~> 1.2.0' > /dev/null 2>&1) || sudo gem install bundler --no-rdoc --no-ri")
    abort "Failed to install bundler"
end

bundle_command = ["bundle"]
bundle_command = bundle_command + [ "install", "--deployment", "--local", "--binstubs=bin", "--path", ".bundle"] unless options[:update_gems]
bundle_command = bundle_command + [ "install", "--no-deployment"] if options[:update_gems]
bundle_command << "--verbose" if options[:debug]
bundle_command << "--quiet" unless options[:debug]
warn bundle_command.join(" ") if options[:debug]
unless system *bundle_command
    abort "There was a problem bootstrapping. Run using --debug for more information"
end

# Add local deps to the load path.

require "rubygems"
require "bundler/setup"

# Possibly updating the cookbooks

unless File.exists?("vendor/cookbooks")
    librarian_command = ["bin/librarian-chef", "install", "--path=vendor/cookbooks", "--clean" ]
    librarian_command << "--verbose" if options[:debug]
    librarian_command << "--quiet" unless options[:debug]
    warn librarian_command.join(" ") if options[:debug]
    unless system *librarian_command
        abort "Can't install Chef cookbooks with librarian-chef. Run using --debug if you need more information."
    end
end

if options[:update_cookbooks]
    librarian_command = ["bin/librarian-chef", "update", "--verbose" ]
    warn librarian_command.join(" ") if options[:debug]
    unless system *librarian_command
        abort "Can't update Chef cookbooks with librarian-chef. Run using --debug if you need more information."
    end
end

# Generate the soloist config

require 'yaml'
require 'etc'
default = YAML.load_file('config/default.yml')
recipes = default["recipes"]
attributes = default["attributes"]

peopleconfig = "config/people/#{Etc.getlogin}.yml"
if File.exist?(peopleconfig)
    user = YAML.load_file(peopleconfig)
    recipes = recipes + user["recipes"]
    attributes = attributes.merge!(user["attributes"])
    unless user["groups"].nil?
        user["groups"].each do |group|
            groupconfig = "config/groups/#{group}.yml"
            if File.exist?(groupconfig)
                group = YAML.load_file(groupconfig)
                recipes = recipes + group["recipes"]
                attributes = attributes.merge!(group["attributes"])
            end
        end
    end
end

soloistrc = Hash.new
soloistrc["cookbook_paths"] = ["#{Dir.pwd}/vendor/cookbooks"]
soloistrc["recipes"] = recipes
soloistrc["node_attributes"] = attributes
File.open("soloistrc", 'w') do |out|
    YAML.dump(soloistrc, out)
end

# Run soloist

exit 0 unless options[:soloist]

soloist_command = ["bin/soloist"]
ENV["LOG_LEVEL"] = "error"
ENV["LOG_LEVEL"] = "debug" if options[:debug]
warn soloist_command.join(" ") if options[:debug]
unless system *soloist_command
    abort "There was a problem running solist. Run using --debug for more information"
end
